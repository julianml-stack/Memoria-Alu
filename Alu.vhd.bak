library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity ALU is
    Port (
        -- Entradas
        A       : in  std_logic_vector(7 downto 0);
        B       : in  std_logic_vector(7 downto 0);
        Alu_sel : in  std_logic_vector(1 downto 0); -- '00' suma, '01' resta
        
        -- Salidas
        O_flag  : out std_logic;  -- Overflow flag
        N_flag  : out std_logic;  -- Negative flag  
        Z_flag  : out std_logic;  -- Zero flag
        C_flag  : out std_logic;  -- Carry flag
        Z       : out std_logic_vector(7 downto 0);  -- Resultado
        
        -- Displays 7-segmentos
        dip0    : out std_logic_vector(6 downto 0);  
        dip1    : out std_logic_vector(6 downto 0); 
        dip2    : out std_logic_vector(6 downto 0); 
        dip3    : out std_logic_vector(6 downto 0) 
    );
end ALU;

architecture arch of ALU is
    
    -- Función para convertir hex a 7 segmentos
    function hex_to_7seg(hex : std_logic_vector(3 downto 0)) return std_logic_vector is
        variable segs : std_logic_vector(6 downto 0);
    begin
        case hex is
            when "0000" => segs := "1000000"; -- 0
            when "0001" => segs := "1111001"; -- 1
            when "0010" => segs := "0100100"; -- 2
            when "0011" => segs := "0110000"; -- 3
            when "0100" => segs := "0011001"; -- 4
            when "0101" => segs := "0010010"; -- 5
            when "0110" => segs := "0000010"; -- 6
            when "0111" => segs := "1111000"; -- 7
            when "1000" => segs := "0000000"; -- 8
            when "1001" => segs := "0010000"; -- 9
            when "1010" => segs := "0001000"; -- A
            when "1011" => segs := "0000011"; -- b
            when "1100" => segs := "1000110"; -- C
            when "1101" => segs := "0100001"; -- d
            when "1110" => segs := "0000110"; -- E
            when "1111" => segs := "0001110"; -- F
            when others => segs := "1111111"; -- blank
        end case;
        return segs;
    end function;
    
    signal Result : std_logic_vector(7 downto 0);
    signal NZVC   : std_logic_vector(3 downto 0); -- N,Z,V,C flags

begin

    ALU_PROCESS : process (A, B, Alu_sel)
        variable Sum_uns    : unsigned(8 downto 0);
        variable Diff_uns   : unsigned(8 downto 0);
        variable Temp_uns   : unsigned(8 downto 0);
    begin
        case Alu_sel is
            when "00" => -- SUMA
                -- Cálculo de la suma
                Sum_uns := unsigned('0' & A) + unsigned('0' & B);
                Result <= std_logic_vector(Sum_uns(7 downto 0));
                
                -- Negative Flag (N) - bit más significativo del resultado
                NZVC(3) <= Sum_uns(7);
                
                -- Zero Flag (Z) - resultado igual a cero
                if (Sum_uns(7 downto 0) = x"00") then
                    NZVC(2) <= '1';
                else
                    NZVC(2) <= '0';
                end if;
                
                -- Overflow Flag (V) - desbordamiento en complemento a 2
                if ((A(7)='0' and B(7)='0' and Sum_uns(7)='1') or
                    (A(7)='1' and B(7)='1' and Sum_uns(7)='0')) then
                    NZVC(1) <= '1';
                else
                    NZVC(1) <= '0';
                end if;
                
                -- Carry Flag (C) - acarreo en la suma
                NZVC(0) <= Sum_uns(8);
                
            when "01" => -- RESTA (A - B)
                -- Cálculo de la resta usando complemento a 2
                Diff_uns := unsigned('0' & A) - unsigned('0' & B);
                Result <= std_logic_vector(Diff_uns(7 downto 0));
                
                -- Negative Flag (N)
                NZVC(3) <= Diff_uns(7);
                
                -- Zero Flag (Z)
                if (Diff_uns(7 downto 0) = x"00") then
                    NZVC(2) <= '1';
                else
                    NZVC(2) <= '0';
                end if;
                
                -- Overflow Flag (V) para resta
                if ((A(7)='0' and B(7)='1' and Diff_uns(7)='1') or
                    (A(7)='1' and B(7)='0' and Diff_uns(7)='0')) then
                    NZVC(1) <= '1';
                else
                    NZVC(1) <= '0';
                end if;
                
                -- Carry Flag (C) - borrow en la resta
                -- En resta, C=1 indica que A < B (hubo borrow)
                NZVC(0) <= Diff_uns(8);
                
            when others => -- Operación no definida
                Result <= (others => '0');
                NZVC <= (others => '0');
        end case;
    end process ALU_PROCESS;

    -- Asignación de las banderas a las salidas individuales
    N_flag <= NZVC(3);
    Z_flag <= NZVC(2);
    O_flag <= NZVC(1);  -- Overflow flag
    C_flag <= NZVC(0);
    
    -- Salida del resultado
    Z <= Result;

    -- Display 7 segmentos
    -- dip0: nibble bajo del resultado
    dip0 <= hex_to_7seg(Result(3 downto 0));
    
    -- dip1: nibble alto del resultado  
    dip1 <= hex_to_7seg(Result(7 downto 4));
    
    -- dip2: muestra 'b' (letra b)
    dip2 <= hex_to_7seg(B(3 downto 0)); 

    dip3 <= hex_to_7seg(B(7 downto 4)); 

end arch;